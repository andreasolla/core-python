#!/usr/bin/env python
#
# Autogenerated by Thrift Compiler (0.15.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

import sys
import pprint
if sys.version_info[0] > 2:
    from urllib.parse import urlparse
else:
    from urlparse import urlparse
from thrift.transport import TTransport, TSocket, TSSLSocket, THttpClient
from thrift.protocol.TBinaryProtocol import TBinaryProtocol

from ignis.rpc.executor.general import IGeneralModule
from ignis.rpc.executor.general.ttypes import *

if len(sys.argv) <= 1 or sys.argv[1] == '--help':
    print('')
    print('Usage: ' + sys.argv[0] + ' [-h host[:port]] [-u url] [-f[ramed]] [-s[sl]] [-novalidate] [-ca_certs certs] [-keyfile keyfile] [-certfile certfile] function [arg1 [arg2...]]')
    print('')
    print('Functions:')
    print('  void executeTo(ISource src)')
    print('  void map_(ISource src)')
    print('  void filter(ISource src)')
    print('  void flatmap(ISource src)')
    print('  void keyBy(ISource src)')
    print('  void mapWithIndex(ISource src)')
    print('  void mapPartitions(ISource src)')
    print('  void mapPartitionsWithIndex(ISource src)')
    print('  void mapExecutor(ISource src)')
    print('  void mapExecutorTo(ISource src)')
    print('  void groupBy(ISource src, i64 numPartitions)')
    print('  void sort(bool ascending)')
    print('  void sort2(bool ascending, i64 numPartitions)')
    print('  void sortBy(ISource src, bool ascending)')
    print('  void sortBy3(ISource src, bool ascending, i64 numPartitions)')
    print('  void union_(string other, bool preserveOrder)')
    print('  void union2(string other, bool preserveOrder, ISource src)')
    print('  void join(string other, i64 numPartitions)')
    print('  void join3(string other, i64 numPartitions, ISource src)')
    print('  void distinct(i64 numPartitions)')
    print('  void distinct2(i64 numPartitions, ISource src)')
    print('  void repartition(i64 numPartitions, bool preserveOrdering, bool global_)')
    print('  void partitionByRandom(i64 numPartitions, i32 seed)')
    print('  void partitionByHash(i64 numPartitions)')
    print('  void partitionBy(ISource src, i64 numPartitions)')
    print('  void flatMapValues(ISource src)')
    print('  void mapValues(ISource src)')
    print('  void groupByKey(i64 numPartitions)')
    print('  void groupByKey2(i64 numPartitions, ISource src)')
    print('  void reduceByKey(ISource src, i64 numPartitions, bool localReduce)')
    print('  void aggregateByKey(ISource zero, ISource seqOp, i64 numPartitions)')
    print('  void aggregateByKey4(ISource zero, ISource seqOp, ISource combOp, i64 numPartitions)')
    print('  void foldByKey(ISource zero, ISource src, i64 numPartitions, bool localFold)')
    print('  void sortByKey(bool ascending)')
    print('  void sortByKey2a(bool ascending, i64 numPartitions)')
    print('  void sortByKey2b(ISource src, bool ascending)')
    print('  void sortByKey3(ISource src, bool ascending, i64 numPartitions)')
    print('')
    sys.exit(0)

pp = pprint.PrettyPrinter(indent=2)
host = 'localhost'
port = 9090
uri = ''
framed = False
ssl = False
validate = True
ca_certs = None
keyfile = None
certfile = None
http = False
argi = 1

if sys.argv[argi] == '-h':
    parts = sys.argv[argi + 1].split(':')
    host = parts[0]
    if len(parts) > 1:
        port = int(parts[1])
    argi += 2

if sys.argv[argi] == '-u':
    url = urlparse(sys.argv[argi + 1])
    parts = url[1].split(':')
    host = parts[0]
    if len(parts) > 1:
        port = int(parts[1])
    else:
        port = 80
    uri = url[2]
    if url[4]:
        uri += '?%s' % url[4]
    http = True
    argi += 2

if sys.argv[argi] == '-f' or sys.argv[argi] == '-framed':
    framed = True
    argi += 1

if sys.argv[argi] == '-s' or sys.argv[argi] == '-ssl':
    ssl = True
    argi += 1

if sys.argv[argi] == '-novalidate':
    validate = False
    argi += 1

if sys.argv[argi] == '-ca_certs':
    ca_certs = sys.argv[argi+1]
    argi += 2

if sys.argv[argi] == '-keyfile':
    keyfile = sys.argv[argi+1]
    argi += 2

if sys.argv[argi] == '-certfile':
    certfile = sys.argv[argi+1]
    argi += 2

cmd = sys.argv[argi]
args = sys.argv[argi + 1:]

if http:
    transport = THttpClient.THttpClient(host, port, uri)
else:
    if ssl:
        socket = TSSLSocket.TSSLSocket(host, port, validate=validate, ca_certs=ca_certs, keyfile=keyfile, certfile=certfile)
    else:
        socket = TSocket.TSocket(host, port)
    if framed:
        transport = TTransport.TFramedTransport(socket)
    else:
        transport = TTransport.TBufferedTransport(socket)
protocol = TBinaryProtocol(transport)
client = IGeneralModule.Client(protocol)
transport.open()

if cmd == 'executeTo':
    if len(args) != 1:
        print('executeTo requires 1 args')
        sys.exit(1)
    pp.pprint(client.executeTo(eval(args[0]),))

elif cmd == 'map_':
    if len(args) != 1:
        print('map_ requires 1 args')
        sys.exit(1)
    pp.pprint(client.map_(eval(args[0]),))

elif cmd == 'filter':
    if len(args) != 1:
        print('filter requires 1 args')
        sys.exit(1)
    pp.pprint(client.filter(eval(args[0]),))

elif cmd == 'flatmap':
    if len(args) != 1:
        print('flatmap requires 1 args')
        sys.exit(1)
    pp.pprint(client.flatmap(eval(args[0]),))

elif cmd == 'keyBy':
    if len(args) != 1:
        print('keyBy requires 1 args')
        sys.exit(1)
    pp.pprint(client.keyBy(eval(args[0]),))

elif cmd == 'mapWithIndex':
    if len(args) != 1:
        print('mapWithIndex requires 1 args')
        sys.exit(1)
    pp.pprint(client.mapWithIndex(eval(args[0]),))

elif cmd == 'mapPartitions':
    if len(args) != 1:
        print('mapPartitions requires 1 args')
        sys.exit(1)
    pp.pprint(client.mapPartitions(eval(args[0]),))

elif cmd == 'mapPartitionsWithIndex':
    if len(args) != 1:
        print('mapPartitionsWithIndex requires 1 args')
        sys.exit(1)
    pp.pprint(client.mapPartitionsWithIndex(eval(args[0]),))

elif cmd == 'mapExecutor':
    if len(args) != 1:
        print('mapExecutor requires 1 args')
        sys.exit(1)
    pp.pprint(client.mapExecutor(eval(args[0]),))

elif cmd == 'mapExecutorTo':
    if len(args) != 1:
        print('mapExecutorTo requires 1 args')
        sys.exit(1)
    pp.pprint(client.mapExecutorTo(eval(args[0]),))

elif cmd == 'groupBy':
    if len(args) != 2:
        print('groupBy requires 2 args')
        sys.exit(1)
    pp.pprint(client.groupBy(eval(args[0]), eval(args[1]),))

elif cmd == 'sort':
    if len(args) != 1:
        print('sort requires 1 args')
        sys.exit(1)
    pp.pprint(client.sort(eval(args[0]),))

elif cmd == 'sort2':
    if len(args) != 2:
        print('sort2 requires 2 args')
        sys.exit(1)
    pp.pprint(client.sort2(eval(args[0]), eval(args[1]),))

elif cmd == 'sortBy':
    if len(args) != 2:
        print('sortBy requires 2 args')
        sys.exit(1)
    pp.pprint(client.sortBy(eval(args[0]), eval(args[1]),))

elif cmd == 'sortBy3':
    if len(args) != 3:
        print('sortBy3 requires 3 args')
        sys.exit(1)
    pp.pprint(client.sortBy3(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'union_':
    if len(args) != 2:
        print('union_ requires 2 args')
        sys.exit(1)
    pp.pprint(client.union_(args[0], eval(args[1]),))

elif cmd == 'union2':
    if len(args) != 3:
        print('union2 requires 3 args')
        sys.exit(1)
    pp.pprint(client.union2(args[0], eval(args[1]), eval(args[2]),))

elif cmd == 'join':
    if len(args) != 2:
        print('join requires 2 args')
        sys.exit(1)
    pp.pprint(client.join(args[0], eval(args[1]),))

elif cmd == 'join3':
    if len(args) != 3:
        print('join3 requires 3 args')
        sys.exit(1)
    pp.pprint(client.join3(args[0], eval(args[1]), eval(args[2]),))

elif cmd == 'distinct':
    if len(args) != 1:
        print('distinct requires 1 args')
        sys.exit(1)
    pp.pprint(client.distinct(eval(args[0]),))

elif cmd == 'distinct2':
    if len(args) != 2:
        print('distinct2 requires 2 args')
        sys.exit(1)
    pp.pprint(client.distinct2(eval(args[0]), eval(args[1]),))

elif cmd == 'repartition':
    if len(args) != 3:
        print('repartition requires 3 args')
        sys.exit(1)
    pp.pprint(client.repartition(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'partitionByRandom':
    if len(args) != 2:
        print('partitionByRandom requires 2 args')
        sys.exit(1)
    pp.pprint(client.partitionByRandom(eval(args[0]), eval(args[1]),))

elif cmd == 'partitionByHash':
    if len(args) != 1:
        print('partitionByHash requires 1 args')
        sys.exit(1)
    pp.pprint(client.partitionByHash(eval(args[0]),))

elif cmd == 'partitionBy':
    if len(args) != 2:
        print('partitionBy requires 2 args')
        sys.exit(1)
    pp.pprint(client.partitionBy(eval(args[0]), eval(args[1]),))

elif cmd == 'flatMapValues':
    if len(args) != 1:
        print('flatMapValues requires 1 args')
        sys.exit(1)
    pp.pprint(client.flatMapValues(eval(args[0]),))

elif cmd == 'mapValues':
    if len(args) != 1:
        print('mapValues requires 1 args')
        sys.exit(1)
    pp.pprint(client.mapValues(eval(args[0]),))

elif cmd == 'groupByKey':
    if len(args) != 1:
        print('groupByKey requires 1 args')
        sys.exit(1)
    pp.pprint(client.groupByKey(eval(args[0]),))

elif cmd == 'groupByKey2':
    if len(args) != 2:
        print('groupByKey2 requires 2 args')
        sys.exit(1)
    pp.pprint(client.groupByKey2(eval(args[0]), eval(args[1]),))

elif cmd == 'reduceByKey':
    if len(args) != 3:
        print('reduceByKey requires 3 args')
        sys.exit(1)
    pp.pprint(client.reduceByKey(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'aggregateByKey':
    if len(args) != 3:
        print('aggregateByKey requires 3 args')
        sys.exit(1)
    pp.pprint(client.aggregateByKey(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'aggregateByKey4':
    if len(args) != 4:
        print('aggregateByKey4 requires 4 args')
        sys.exit(1)
    pp.pprint(client.aggregateByKey4(eval(args[0]), eval(args[1]), eval(args[2]), eval(args[3]),))

elif cmd == 'foldByKey':
    if len(args) != 4:
        print('foldByKey requires 4 args')
        sys.exit(1)
    pp.pprint(client.foldByKey(eval(args[0]), eval(args[1]), eval(args[2]), eval(args[3]),))

elif cmd == 'sortByKey':
    if len(args) != 1:
        print('sortByKey requires 1 args')
        sys.exit(1)
    pp.pprint(client.sortByKey(eval(args[0]),))

elif cmd == 'sortByKey2a':
    if len(args) != 2:
        print('sortByKey2a requires 2 args')
        sys.exit(1)
    pp.pprint(client.sortByKey2a(eval(args[0]), eval(args[1]),))

elif cmd == 'sortByKey2b':
    if len(args) != 2:
        print('sortByKey2b requires 2 args')
        sys.exit(1)
    pp.pprint(client.sortByKey2b(eval(args[0]), eval(args[1]),))

elif cmd == 'sortByKey3':
    if len(args) != 3:
        print('sortByKey3 requires 3 args')
        sys.exit(1)
    pp.pprint(client.sortByKey3(eval(args[0]), eval(args[1]), eval(args[2]),))

else:
    print('Unrecognized method %s' % cmd)
    sys.exit(1)

transport.close()
