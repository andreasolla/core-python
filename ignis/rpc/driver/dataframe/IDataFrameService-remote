#!/usr/bin/env python
#
# Autogenerated by Thrift Compiler (0.15.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

import sys
import pprint
if sys.version_info[0] > 2:
    from urllib.parse import urlparse
else:
    from urlparse import urlparse
from thrift.transport import TTransport, TSocket, TSSLSocket, THttpClient
from thrift.protocol.TBinaryProtocol import TBinaryProtocol

from ignis.rpc.driver.dataframe import IDataFrameService
from ignis.rpc.driver.dataframe.ttypes import *

if len(sys.argv) <= 1 or sys.argv[1] == '--help':
    print('')
    print('Usage: ' + sys.argv[0] + ' [-h host[:port]] [-u url] [-f[ramed]] [-s[sl]] [-novalidate] [-ca_certs certs] [-keyfile keyfile] [-certfile certfile] function [arg1 [arg2...]]')
    print('')
    print('Functions:')
    print('  void setName(IDataFrameId id, string name)')
    print('  void persist(IDataFrameId id, i8 level)')
    print('  void cache(IDataFrameId id)')
    print('  void unpersist(IDataFrameId id)')
    print('  void uncache(IDataFrameId id)')
    print('  i64 partitions(IDataFrameId id)')
    print('  void saveAsObjectFile(IDataFrameId id, string path, i8 compression)')
    print('  void saveAsTextFile(IDataFrameId id, string path)')
    print('  void saveAsJsonFile(IDataFrameId id, string path, bool pretty)')
    print('  IDataFrameId repartition(IDataFrameId id, i64 numPartitions, bool preserveOrdering, bool global_)')
    print('  IDataFrameId partitionByRandom(IDataFrameId id, i64 numPartitions, i32 seed)')
    print('  IDataFrameId partitionByHash(IDataFrameId id, i64 numPartitions)')
    print('  IDataFrameId partitionBy(IDataFrameId id, ISource src, i64 numPartitions)')
    print('  IDataFrameId map_(IDataFrameId id, ISource src)')
    print('  IDataFrameId filter(IDataFrameId id, ISource src)')
    print('  IDataFrameId flatmap(IDataFrameId id, ISource src)')
    print('  IDataFrameId keyBy(IDataFrameId id, ISource src)')
    print('  IDataFrameId mapWithIndex(IDataFrameId id, ISource src)')
    print('  IDataFrameId mapPartitions(IDataFrameId id, ISource src)')
    print('  IDataFrameId mapPartitionsWithIndex(IDataFrameId id, ISource src)')
    print('  IDataFrameId mapExecutor(IDataFrameId id, ISource src)')
    print('  IDataFrameId mapExecutorTo(IDataFrameId id, ISource src)')
    print('  IDataFrameId groupBy(IDataFrameId id, ISource src)')
    print('  IDataFrameId groupBy2(IDataFrameId id, ISource src, i64 numPartitions)')
    print('  IDataFrameId sort(IDataFrameId id, bool ascending)')
    print('  IDataFrameId sort2(IDataFrameId id, bool ascending, i64 numPartitions)')
    print('  IDataFrameId sortBy(IDataFrameId id, ISource src, bool ascending)')
    print('  IDataFrameId sortBy3(IDataFrameId id, ISource src, bool ascending, i64 numPartitions)')
    print('  IDataFrameId union_(IDataFrameId id, IDataFrameId other, bool preserveOrder)')
    print('  IDataFrameId union4(IDataFrameId id, IDataFrameId other, bool preserveOrder, ISource src)')
    print('  IDataFrameId join(IDataFrameId id, IDataFrameId other)')
    print('  IDataFrameId join3a(IDataFrameId id, IDataFrameId other, i64 numPartitions)')
    print('  IDataFrameId join3b(IDataFrameId id, IDataFrameId other, ISource src)')
    print('  IDataFrameId join4(IDataFrameId id, IDataFrameId other, i64 numPartitions, ISource src)')
    print('  IDataFrameId distinct(IDataFrameId id)')
    print('  IDataFrameId distinct2a(IDataFrameId id, i64 numPartitions)')
    print('  IDataFrameId distinct2b(IDataFrameId id, ISource src)')
    print('  IDataFrameId distinct3(IDataFrameId id, i64 numPartitions, ISource src)')
    print('  i64 reduce(IDataFrameId id, ISource src, ISource tp)')
    print('  i64 treeReduce(IDataFrameId id, ISource src, ISource tp)')
    print('  i64 collect(IDataFrameId id, ISource tp)')
    print('  i64 aggregate(IDataFrameId id, ISource zero, ISource seqOp, ISource combOp, ISource tp)')
    print('  i64 treeAggregate(IDataFrameId id, ISource zero, ISource seqOp, ISource combOp, ISource tp)')
    print('  i64 fold(IDataFrameId id, ISource zero, ISource src, ISource tp)')
    print('  i64 treeFold(IDataFrameId id, ISource zero, ISource src, ISource tp)')
    print('  i64 take(IDataFrameId id, i64 num, ISource tp)')
    print('  void foreach_(IDataFrameId id, ISource src)')
    print('  void foreachPartition(IDataFrameId id, ISource src)')
    print('  void foreachExecutor(IDataFrameId id, ISource src)')
    print('  i64 top(IDataFrameId id, i64 num, ISource tp)')
    print('  i64 top4(IDataFrameId id, i64 num, ISource cmp, ISource tp)')
    print('  i64 takeOrdered(IDataFrameId id, i64 num, ISource tp)')
    print('  i64 takeOrdered4(IDataFrameId id, i64 num, ISource cmp, ISource tp)')
    print('  IDataFrameId sample(IDataFrameId id, bool withReplacement, double fraction, i32 seed)')
    print('  i64 takeSample(IDataFrameId id, bool withReplacement, i64 num, i32 seed, ISource tp)')
    print('  i64 count(IDataFrameId id)')
    print('  i64 max(IDataFrameId id, ISource tp)')
    print('  i64 max3(IDataFrameId id, ISource cmp, ISource tp)')
    print('  i64 min(IDataFrameId id, ISource tp)')
    print('  i64 min3(IDataFrameId id, ISource cmp, ISource tp)')
    print('  IDataFrameId flatMapValues(IDataFrameId id, ISource src)')
    print('  IDataFrameId mapValues(IDataFrameId id, ISource src)')
    print('  IDataFrameId groupByKey(IDataFrameId id)')
    print('  IDataFrameId groupByKey2a(IDataFrameId id, i64 numPartitions)')
    print('  IDataFrameId groupByKey2b(IDataFrameId id, ISource src)')
    print('  IDataFrameId groupByKey3(IDataFrameId id, i64 numPartitions, ISource src)')
    print('  IDataFrameId reduceByKey(IDataFrameId id, ISource src, bool localReduce)')
    print('  IDataFrameId reduceByKey4(IDataFrameId id, ISource src, i64 numPartitions, bool localReduce)')
    print('  IDataFrameId aggregateByKey(IDataFrameId id, ISource zero, ISource seqOp)')
    print('  IDataFrameId aggregateByKey4a(IDataFrameId id, ISource zero, ISource seqOp, i64 numPartitions)')
    print('  IDataFrameId aggregateByKey4b(IDataFrameId id, ISource zero, ISource seqOp, ISource combOp)')
    print('  IDataFrameId aggregateByKey5(IDataFrameId id, ISource zero, ISource seqOp, ISource combOp, i64 numPartitions)')
    print('  IDataFrameId foldByKey(IDataFrameId id, ISource zero, ISource src, bool localFold)')
    print('  IDataFrameId foldByKey5(IDataFrameId id, ISource zero, ISource src, i64 numPartitions, bool localFold)')
    print('  IDataFrameId sortByKey(IDataFrameId id, bool ascending)')
    print('  IDataFrameId sortByKey3a(IDataFrameId id, bool ascending, i64 numPartitions)')
    print('  IDataFrameId sortByKey3b(IDataFrameId id, ISource src, bool ascending)')
    print('  IDataFrameId sortByKey4(IDataFrameId id, ISource src, bool ascending, i64 numPartitions)')
    print('  i64 keys(IDataFrameId id, ISource tp)')
    print('  i64 values(IDataFrameId id, ISource tp)')
    print('  IDataFrameId sampleByKey(IDataFrameId id, bool withReplacement, ISource fractions, i32 seed)')
    print('  i64 countByKey(IDataFrameId id, ISource tp)')
    print('  i64 countByValue(IDataFrameId id, ISource tp)')
    print('')
    sys.exit(0)

pp = pprint.PrettyPrinter(indent=2)
host = 'localhost'
port = 9090
uri = ''
framed = False
ssl = False
validate = True
ca_certs = None
keyfile = None
certfile = None
http = False
argi = 1

if sys.argv[argi] == '-h':
    parts = sys.argv[argi + 1].split(':')
    host = parts[0]
    if len(parts) > 1:
        port = int(parts[1])
    argi += 2

if sys.argv[argi] == '-u':
    url = urlparse(sys.argv[argi + 1])
    parts = url[1].split(':')
    host = parts[0]
    if len(parts) > 1:
        port = int(parts[1])
    else:
        port = 80
    uri = url[2]
    if url[4]:
        uri += '?%s' % url[4]
    http = True
    argi += 2

if sys.argv[argi] == '-f' or sys.argv[argi] == '-framed':
    framed = True
    argi += 1

if sys.argv[argi] == '-s' or sys.argv[argi] == '-ssl':
    ssl = True
    argi += 1

if sys.argv[argi] == '-novalidate':
    validate = False
    argi += 1

if sys.argv[argi] == '-ca_certs':
    ca_certs = sys.argv[argi+1]
    argi += 2

if sys.argv[argi] == '-keyfile':
    keyfile = sys.argv[argi+1]
    argi += 2

if sys.argv[argi] == '-certfile':
    certfile = sys.argv[argi+1]
    argi += 2

cmd = sys.argv[argi]
args = sys.argv[argi + 1:]

if http:
    transport = THttpClient.THttpClient(host, port, uri)
else:
    if ssl:
        socket = TSSLSocket.TSSLSocket(host, port, validate=validate, ca_certs=ca_certs, keyfile=keyfile, certfile=certfile)
    else:
        socket = TSocket.TSocket(host, port)
    if framed:
        transport = TTransport.TFramedTransport(socket)
    else:
        transport = TTransport.TBufferedTransport(socket)
protocol = TBinaryProtocol(transport)
client = IDataFrameService.Client(protocol)
transport.open()

if cmd == 'setName':
    if len(args) != 2:
        print('setName requires 2 args')
        sys.exit(1)
    pp.pprint(client.setName(eval(args[0]), args[1],))

elif cmd == 'persist':
    if len(args) != 2:
        print('persist requires 2 args')
        sys.exit(1)
    pp.pprint(client.persist(eval(args[0]), eval(args[1]),))

elif cmd == 'cache':
    if len(args) != 1:
        print('cache requires 1 args')
        sys.exit(1)
    pp.pprint(client.cache(eval(args[0]),))

elif cmd == 'unpersist':
    if len(args) != 1:
        print('unpersist requires 1 args')
        sys.exit(1)
    pp.pprint(client.unpersist(eval(args[0]),))

elif cmd == 'uncache':
    if len(args) != 1:
        print('uncache requires 1 args')
        sys.exit(1)
    pp.pprint(client.uncache(eval(args[0]),))

elif cmd == 'partitions':
    if len(args) != 1:
        print('partitions requires 1 args')
        sys.exit(1)
    pp.pprint(client.partitions(eval(args[0]),))

elif cmd == 'saveAsObjectFile':
    if len(args) != 3:
        print('saveAsObjectFile requires 3 args')
        sys.exit(1)
    pp.pprint(client.saveAsObjectFile(eval(args[0]), args[1], eval(args[2]),))

elif cmd == 'saveAsTextFile':
    if len(args) != 2:
        print('saveAsTextFile requires 2 args')
        sys.exit(1)
    pp.pprint(client.saveAsTextFile(eval(args[0]), args[1],))

elif cmd == 'saveAsJsonFile':
    if len(args) != 3:
        print('saveAsJsonFile requires 3 args')
        sys.exit(1)
    pp.pprint(client.saveAsJsonFile(eval(args[0]), args[1], eval(args[2]),))

elif cmd == 'repartition':
    if len(args) != 4:
        print('repartition requires 4 args')
        sys.exit(1)
    pp.pprint(client.repartition(eval(args[0]), eval(args[1]), eval(args[2]), eval(args[3]),))

elif cmd == 'partitionByRandom':
    if len(args) != 3:
        print('partitionByRandom requires 3 args')
        sys.exit(1)
    pp.pprint(client.partitionByRandom(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'partitionByHash':
    if len(args) != 2:
        print('partitionByHash requires 2 args')
        sys.exit(1)
    pp.pprint(client.partitionByHash(eval(args[0]), eval(args[1]),))

elif cmd == 'partitionBy':
    if len(args) != 3:
        print('partitionBy requires 3 args')
        sys.exit(1)
    pp.pprint(client.partitionBy(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'map_':
    if len(args) != 2:
        print('map_ requires 2 args')
        sys.exit(1)
    pp.pprint(client.map_(eval(args[0]), eval(args[1]),))

elif cmd == 'filter':
    if len(args) != 2:
        print('filter requires 2 args')
        sys.exit(1)
    pp.pprint(client.filter(eval(args[0]), eval(args[1]),))

elif cmd == 'flatmap':
    if len(args) != 2:
        print('flatmap requires 2 args')
        sys.exit(1)
    pp.pprint(client.flatmap(eval(args[0]), eval(args[1]),))

elif cmd == 'keyBy':
    if len(args) != 2:
        print('keyBy requires 2 args')
        sys.exit(1)
    pp.pprint(client.keyBy(eval(args[0]), eval(args[1]),))

elif cmd == 'mapWithIndex':
    if len(args) != 2:
        print('mapWithIndex requires 2 args')
        sys.exit(1)
    pp.pprint(client.mapWithIndex(eval(args[0]), eval(args[1]),))

elif cmd == 'mapPartitions':
    if len(args) != 2:
        print('mapPartitions requires 2 args')
        sys.exit(1)
    pp.pprint(client.mapPartitions(eval(args[0]), eval(args[1]),))

elif cmd == 'mapPartitionsWithIndex':
    if len(args) != 2:
        print('mapPartitionsWithIndex requires 2 args')
        sys.exit(1)
    pp.pprint(client.mapPartitionsWithIndex(eval(args[0]), eval(args[1]),))

elif cmd == 'mapExecutor':
    if len(args) != 2:
        print('mapExecutor requires 2 args')
        sys.exit(1)
    pp.pprint(client.mapExecutor(eval(args[0]), eval(args[1]),))

elif cmd == 'mapExecutorTo':
    if len(args) != 2:
        print('mapExecutorTo requires 2 args')
        sys.exit(1)
    pp.pprint(client.mapExecutorTo(eval(args[0]), eval(args[1]),))

elif cmd == 'groupBy':
    if len(args) != 2:
        print('groupBy requires 2 args')
        sys.exit(1)
    pp.pprint(client.groupBy(eval(args[0]), eval(args[1]),))

elif cmd == 'groupBy2':
    if len(args) != 3:
        print('groupBy2 requires 3 args')
        sys.exit(1)
    pp.pprint(client.groupBy2(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'sort':
    if len(args) != 2:
        print('sort requires 2 args')
        sys.exit(1)
    pp.pprint(client.sort(eval(args[0]), eval(args[1]),))

elif cmd == 'sort2':
    if len(args) != 3:
        print('sort2 requires 3 args')
        sys.exit(1)
    pp.pprint(client.sort2(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'sortBy':
    if len(args) != 3:
        print('sortBy requires 3 args')
        sys.exit(1)
    pp.pprint(client.sortBy(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'sortBy3':
    if len(args) != 4:
        print('sortBy3 requires 4 args')
        sys.exit(1)
    pp.pprint(client.sortBy3(eval(args[0]), eval(args[1]), eval(args[2]), eval(args[3]),))

elif cmd == 'union_':
    if len(args) != 3:
        print('union_ requires 3 args')
        sys.exit(1)
    pp.pprint(client.union_(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'union4':
    if len(args) != 4:
        print('union4 requires 4 args')
        sys.exit(1)
    pp.pprint(client.union4(eval(args[0]), eval(args[1]), eval(args[2]), eval(args[3]),))

elif cmd == 'join':
    if len(args) != 2:
        print('join requires 2 args')
        sys.exit(1)
    pp.pprint(client.join(eval(args[0]), eval(args[1]),))

elif cmd == 'join3a':
    if len(args) != 3:
        print('join3a requires 3 args')
        sys.exit(1)
    pp.pprint(client.join3a(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'join3b':
    if len(args) != 3:
        print('join3b requires 3 args')
        sys.exit(1)
    pp.pprint(client.join3b(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'join4':
    if len(args) != 4:
        print('join4 requires 4 args')
        sys.exit(1)
    pp.pprint(client.join4(eval(args[0]), eval(args[1]), eval(args[2]), eval(args[3]),))

elif cmd == 'distinct':
    if len(args) != 1:
        print('distinct requires 1 args')
        sys.exit(1)
    pp.pprint(client.distinct(eval(args[0]),))

elif cmd == 'distinct2a':
    if len(args) != 2:
        print('distinct2a requires 2 args')
        sys.exit(1)
    pp.pprint(client.distinct2a(eval(args[0]), eval(args[1]),))

elif cmd == 'distinct2b':
    if len(args) != 2:
        print('distinct2b requires 2 args')
        sys.exit(1)
    pp.pprint(client.distinct2b(eval(args[0]), eval(args[1]),))

elif cmd == 'distinct3':
    if len(args) != 3:
        print('distinct3 requires 3 args')
        sys.exit(1)
    pp.pprint(client.distinct3(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'reduce':
    if len(args) != 3:
        print('reduce requires 3 args')
        sys.exit(1)
    pp.pprint(client.reduce(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'treeReduce':
    if len(args) != 3:
        print('treeReduce requires 3 args')
        sys.exit(1)
    pp.pprint(client.treeReduce(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'collect':
    if len(args) != 2:
        print('collect requires 2 args')
        sys.exit(1)
    pp.pprint(client.collect(eval(args[0]), eval(args[1]),))

elif cmd == 'aggregate':
    if len(args) != 5:
        print('aggregate requires 5 args')
        sys.exit(1)
    pp.pprint(client.aggregate(eval(args[0]), eval(args[1]), eval(args[2]), eval(args[3]), eval(args[4]),))

elif cmd == 'treeAggregate':
    if len(args) != 5:
        print('treeAggregate requires 5 args')
        sys.exit(1)
    pp.pprint(client.treeAggregate(eval(args[0]), eval(args[1]), eval(args[2]), eval(args[3]), eval(args[4]),))

elif cmd == 'fold':
    if len(args) != 4:
        print('fold requires 4 args')
        sys.exit(1)
    pp.pprint(client.fold(eval(args[0]), eval(args[1]), eval(args[2]), eval(args[3]),))

elif cmd == 'treeFold':
    if len(args) != 4:
        print('treeFold requires 4 args')
        sys.exit(1)
    pp.pprint(client.treeFold(eval(args[0]), eval(args[1]), eval(args[2]), eval(args[3]),))

elif cmd == 'take':
    if len(args) != 3:
        print('take requires 3 args')
        sys.exit(1)
    pp.pprint(client.take(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'foreach_':
    if len(args) != 2:
        print('foreach_ requires 2 args')
        sys.exit(1)
    pp.pprint(client.foreach_(eval(args[0]), eval(args[1]),))

elif cmd == 'foreachPartition':
    if len(args) != 2:
        print('foreachPartition requires 2 args')
        sys.exit(1)
    pp.pprint(client.foreachPartition(eval(args[0]), eval(args[1]),))

elif cmd == 'foreachExecutor':
    if len(args) != 2:
        print('foreachExecutor requires 2 args')
        sys.exit(1)
    pp.pprint(client.foreachExecutor(eval(args[0]), eval(args[1]),))

elif cmd == 'top':
    if len(args) != 3:
        print('top requires 3 args')
        sys.exit(1)
    pp.pprint(client.top(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'top4':
    if len(args) != 4:
        print('top4 requires 4 args')
        sys.exit(1)
    pp.pprint(client.top4(eval(args[0]), eval(args[1]), eval(args[2]), eval(args[3]),))

elif cmd == 'takeOrdered':
    if len(args) != 3:
        print('takeOrdered requires 3 args')
        sys.exit(1)
    pp.pprint(client.takeOrdered(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'takeOrdered4':
    if len(args) != 4:
        print('takeOrdered4 requires 4 args')
        sys.exit(1)
    pp.pprint(client.takeOrdered4(eval(args[0]), eval(args[1]), eval(args[2]), eval(args[3]),))

elif cmd == 'sample':
    if len(args) != 4:
        print('sample requires 4 args')
        sys.exit(1)
    pp.pprint(client.sample(eval(args[0]), eval(args[1]), eval(args[2]), eval(args[3]),))

elif cmd == 'takeSample':
    if len(args) != 5:
        print('takeSample requires 5 args')
        sys.exit(1)
    pp.pprint(client.takeSample(eval(args[0]), eval(args[1]), eval(args[2]), eval(args[3]), eval(args[4]),))

elif cmd == 'count':
    if len(args) != 1:
        print('count requires 1 args')
        sys.exit(1)
    pp.pprint(client.count(eval(args[0]),))

elif cmd == 'max':
    if len(args) != 2:
        print('max requires 2 args')
        sys.exit(1)
    pp.pprint(client.max(eval(args[0]), eval(args[1]),))

elif cmd == 'max3':
    if len(args) != 3:
        print('max3 requires 3 args')
        sys.exit(1)
    pp.pprint(client.max3(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'min':
    if len(args) != 2:
        print('min requires 2 args')
        sys.exit(1)
    pp.pprint(client.min(eval(args[0]), eval(args[1]),))

elif cmd == 'min3':
    if len(args) != 3:
        print('min3 requires 3 args')
        sys.exit(1)
    pp.pprint(client.min3(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'flatMapValues':
    if len(args) != 2:
        print('flatMapValues requires 2 args')
        sys.exit(1)
    pp.pprint(client.flatMapValues(eval(args[0]), eval(args[1]),))

elif cmd == 'mapValues':
    if len(args) != 2:
        print('mapValues requires 2 args')
        sys.exit(1)
    pp.pprint(client.mapValues(eval(args[0]), eval(args[1]),))

elif cmd == 'groupByKey':
    if len(args) != 1:
        print('groupByKey requires 1 args')
        sys.exit(1)
    pp.pprint(client.groupByKey(eval(args[0]),))

elif cmd == 'groupByKey2a':
    if len(args) != 2:
        print('groupByKey2a requires 2 args')
        sys.exit(1)
    pp.pprint(client.groupByKey2a(eval(args[0]), eval(args[1]),))

elif cmd == 'groupByKey2b':
    if len(args) != 2:
        print('groupByKey2b requires 2 args')
        sys.exit(1)
    pp.pprint(client.groupByKey2b(eval(args[0]), eval(args[1]),))

elif cmd == 'groupByKey3':
    if len(args) != 3:
        print('groupByKey3 requires 3 args')
        sys.exit(1)
    pp.pprint(client.groupByKey3(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'reduceByKey':
    if len(args) != 3:
        print('reduceByKey requires 3 args')
        sys.exit(1)
    pp.pprint(client.reduceByKey(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'reduceByKey4':
    if len(args) != 4:
        print('reduceByKey4 requires 4 args')
        sys.exit(1)
    pp.pprint(client.reduceByKey4(eval(args[0]), eval(args[1]), eval(args[2]), eval(args[3]),))

elif cmd == 'aggregateByKey':
    if len(args) != 3:
        print('aggregateByKey requires 3 args')
        sys.exit(1)
    pp.pprint(client.aggregateByKey(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'aggregateByKey4a':
    if len(args) != 4:
        print('aggregateByKey4a requires 4 args')
        sys.exit(1)
    pp.pprint(client.aggregateByKey4a(eval(args[0]), eval(args[1]), eval(args[2]), eval(args[3]),))

elif cmd == 'aggregateByKey4b':
    if len(args) != 4:
        print('aggregateByKey4b requires 4 args')
        sys.exit(1)
    pp.pprint(client.aggregateByKey4b(eval(args[0]), eval(args[1]), eval(args[2]), eval(args[3]),))

elif cmd == 'aggregateByKey5':
    if len(args) != 5:
        print('aggregateByKey5 requires 5 args')
        sys.exit(1)
    pp.pprint(client.aggregateByKey5(eval(args[0]), eval(args[1]), eval(args[2]), eval(args[3]), eval(args[4]),))

elif cmd == 'foldByKey':
    if len(args) != 4:
        print('foldByKey requires 4 args')
        sys.exit(1)
    pp.pprint(client.foldByKey(eval(args[0]), eval(args[1]), eval(args[2]), eval(args[3]),))

elif cmd == 'foldByKey5':
    if len(args) != 5:
        print('foldByKey5 requires 5 args')
        sys.exit(1)
    pp.pprint(client.foldByKey5(eval(args[0]), eval(args[1]), eval(args[2]), eval(args[3]), eval(args[4]),))

elif cmd == 'sortByKey':
    if len(args) != 2:
        print('sortByKey requires 2 args')
        sys.exit(1)
    pp.pprint(client.sortByKey(eval(args[0]), eval(args[1]),))

elif cmd == 'sortByKey3a':
    if len(args) != 3:
        print('sortByKey3a requires 3 args')
        sys.exit(1)
    pp.pprint(client.sortByKey3a(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'sortByKey3b':
    if len(args) != 3:
        print('sortByKey3b requires 3 args')
        sys.exit(1)
    pp.pprint(client.sortByKey3b(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'sortByKey4':
    if len(args) != 4:
        print('sortByKey4 requires 4 args')
        sys.exit(1)
    pp.pprint(client.sortByKey4(eval(args[0]), eval(args[1]), eval(args[2]), eval(args[3]),))

elif cmd == 'keys':
    if len(args) != 2:
        print('keys requires 2 args')
        sys.exit(1)
    pp.pprint(client.keys(eval(args[0]), eval(args[1]),))

elif cmd == 'values':
    if len(args) != 2:
        print('values requires 2 args')
        sys.exit(1)
    pp.pprint(client.values(eval(args[0]), eval(args[1]),))

elif cmd == 'sampleByKey':
    if len(args) != 4:
        print('sampleByKey requires 4 args')
        sys.exit(1)
    pp.pprint(client.sampleByKey(eval(args[0]), eval(args[1]), eval(args[2]), eval(args[3]),))

elif cmd == 'countByKey':
    if len(args) != 2:
        print('countByKey requires 2 args')
        sys.exit(1)
    pp.pprint(client.countByKey(eval(args[0]), eval(args[1]),))

elif cmd == 'countByValue':
    if len(args) != 2:
        print('countByValue requires 2 args')
        sys.exit(1)
    pp.pprint(client.countByValue(eval(args[0]), eval(args[1]),))

else:
    print('Unrecognized method %s' % cmd)
    sys.exit(1)

transport.close()
